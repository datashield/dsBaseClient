% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ds.Boole.o.R
\name{ds.Boole.o}
\alias{ds.Boole.o}
\title{ds.Boole.o}
\usage{
ds.Boole.o(V1 = NULL, V2 = NULL, Boolean.operator = NULL,
  numeric.output = TRUE, na.assign = "NA", newobj = NULL,
  datasources = NULL)
}
\arguments{
\item{V1}{A character string specifying the name of the vector to which the Boolean operator
is to be applied}

\item{V2}{A character string specifying the name of the vector or scalar to which <V1> is to
be compared. So, if <V2> is a scalar (e.g. '4') and the Boolean operator is '<=', the
output vector will be a binary/Boolean variable with elements taking the value 1 or TRUE
if the corresponding element of <V1> is 4 or less and 0 or FALSE otherwise. On the other
hand, if <V2> is a vector and the Boolean operator is '==', the output vector will be a
binary/Boolean variable with elements taking the value 1 or TRUE if the corresponding
elements of <V1> and <V2> are equal and 0 or FALSE otherwise. If <V2> is a vector rather than
a scalar it must be of the same length as <V1>}

\item{Boolean.operator}{A character string specifying one of six possible Boolean operators:
'==', '!=', '>', '>=', '<', '<='}

\item{numeric.output}{a TRUE/FALSE indicator defaulting to TRUE determining whether the final
output variable should be of class numeric (1/0) or class logical (TRUE/FALSE). It is easy
to convert a logical class variable to numeric using the ds.asNumeric() function and to
convert a numeric (1/0) variable to logical you can apply ds.Boole.o with <Boolean.operator>
'==', <V2> the scalar '1' and <numeric.output> FALSE.}

\item{na.assign}{A character string taking values 'NA', '1' or '0'. If 'NA' then any NA
values in the input vector remain as NAs in the output vector. If '1' or '0' NA values in
the input vector are all converted to 1 or 0 respectively.}

\item{newobj}{A character string specifying the name of the vector to which the output
vector is to be written. If no <newobj> argument is specified, the output vector defaults
to "V1_Boole" where <V1> is the first argument of the function.}

\item{datasources}{specifies the particular opal object(s) to use. If the <datasources>
argument is not specified the default set of opals will be used. The default opals
are called default.opals and the default can be set using the function
{ds.setDefaultOpals.o}. If the <datasources> is to be specified, it should be set without
inverted commas: e.g. datasources=opals.em or datasources=default.opals. If you wish to
apply the function solely to e.g. the second opal server in a set of three,
the argument can be specified as: e.g. datasources=opals.em[2].
If you wish to specify the first and third opal servers in a set you specify:
e.g. datasources=opals.em[c(1,3)]}
}
\value{
the object specified by the <newobj> argument (or default name <V1>_Boole)
which is written to the serverside. In addition, two validity messages are returned
indicating whether <newobj> has been created in each data source and if so whether
it is in a valid form. If its form is not valid in at least one study - e.g. because
a disclosure trap was tripped and creation of the full output object was blocked -
ds.Boole.o also returns any studysideMessages that can explain the error in creating
the full output object. As well as appearing on the screen at run time,if you wish to
see the relevant studysideMessages at a later date you can use the {ds.message.o}
function. If you type ds.message.o("newobj") it will print out the relevant
studysideMessage from any datasource in which there was an error in creating <newobj>
and a studysideMessage was saved. If there was no error and <newobj> was created
without problems no studysideMessage will have been saved and ds.message.o("newobj")
will return the message: "ALL OK: there are no studysideMessage(s) on this datasource".
}
\description{
Converts the individual elements of a vector or other object into Boolean
indicators(TRUE/FALSE or 1/0) based on the standard set of Boolean operators:
==, !=, >, >=, <, <=.
}
\details{
A combination of operators reflected in AND can be obtained by multiplying two or more
binary/Boolean vectors together: observations taking the value 1 in every vector will then
take the value 1 while all others will take the value 0. The combination OR can be obtained by
adding two or more vectors and then then reapply ds.Boole.o using the operator >= 1: any
observation taking the value 1 in one or more vectors will take the value 1 in the final vector.
}
\author{
DataSHIELD Development Team
}
