% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ds.cbind.o.R
\name{ds.cbind.o}
\alias{ds.cbind.o}
\title{ds.cbind.o calling cbindDS.o}
\usage{
ds.cbind.o(x = NULL, DataSHIELD.checks = FALSE,
  force.colnames = NULL, newobj = "cbind.out", datasources = NULL,
  notify.of.progress = FALSE)
}
\arguments{
\item{x}{This is a vector of character strings representing the names of the elemental
components to be combined  For example, the call:
ds.cbind.o(x=c('DF_input','matrix.m','var_age'),newobj='cbind_output') will
combine a pre-existing data.frame called DF_input with a matrix and a variable
called var_age. The output will be the object cbind_output in which
the first columns will be the columns of DF_input, to their right
the next block of columns are from matrix.m and the final column will
be the variable var_age. As many
elemental components as needed may be combined in any order e.g. 3 data.frames,
7 variables and 2 matrices. For convenience the x argument can alternatively
be specified in a two step procedure, the first being a call to
the native R environment on the client server:
x.components<-c('DF_input1','matrix.m','DF_input2', 'var_age'); 
ds.cbind.o(x=x.components,newobj='DF_output'). In order to
disambiguate column names, if the same column name appears several times
the suffix '.1' will be appended to the second instance, '.2' to the
third and, generally, .(n-1) to the nth instance. Disambiguation
does not occur if column names are user specified using <force.colnames>}

\item{DataSHIELD.checks}{logical, if TRUE checks are made that all
input objects exist and are of an appropriate class. These checks
are relatively slow and so the <DataSHIELD.checks> argument is
defaulted to FALSE}

\item{force.colnames}{NULL or a vector of character strings representing
the required column names of the output object. For example:
force.colnames=c("colname1","name.of.second.column", "lastcol") for an
output object with three columns. If <force.colnames> is NULL
column names are inferred from the names or column names of
the input objects - please see 'details' for disambiguation.
If <force.colnames> is not NULL, there is no disambiguation
so you can force columns to have the same names should you
so wish.The vector of column names must have
the same number of elements as there are columns in the output
object. If the length of the column name vector is incorrect a
studysideMessage is returned: "Number of column names
does not match number of columns in output object. Here 'N' names
are required.Please see help for {ds.cbind.o} function" where 'N'
is the actual number of columns in the output object}

\item{newobj}{This a character string providing a name for the output
data.frame which defaults to 'cbind.out' if no name is specified.}

\item{datasources}{specifies the particular opal object(s) to use. If the <datasources>
argument is not specified the default set of opals will be used. The default opals
are called default.opals and the default can be set using the function
{ds.setDefaultOpals.o}. If the <datasources> is to be specified, it should be set without
inverted commas: e.g. datasources=opals.em or datasources=default.opals. If you wish to
apply the function solely to e.g. the second opal server in a set of three,
the argument can be specified as: e.g. datasources=opals.em[2].
If you wish to specify the first and third opal servers in a set you specify:
e.g. datasources=opals.em[c(1,3)]}

\item{notify.of.progress}{specifies if console output should be produce to indicate
progress. The default value for notify.of.progress is FALSE.}
}
\value{
the object specified by the <newobj> argument (or default name <cbind.out>).
which is written to the serverside. Just like the {cbind} function in
native R, the output object is of class matrix unless one or more
of the input objects is a data.frame in which case the class of the
output object is data.frame. In the latter case, if an object of
class matrix is required one may use the {ds.asMatrix.o} function.
As well as writing the output object as <newobj>
on the serverside, two validity messages are returned
indicating whether <newobj> has been created in each data source and if so whether
it is in a valid form. If its form is not valid in at least one study - e.g. because
a disclosure trap was tripped and creation of the full output object was blocked -
ds.cbind.o() also returns any studysideMessages that can explain the error in creating
the full output object. As well as appearing on the screen at run time,if you wish to
see the relevant studysideMessages at a later date you can use the {ds.message.o}
function. If you type ds.message.o("<newobj>") it will print out the relevant
studysideMessage from any datasource in which there was an error in creating <newobj>
and a studysideMessage was saved. If there was no error and <newobj> was created
without problems no studysideMessage will have been saved and ds.message.o("<newobj>")
will return the message: "ALL OK: there are no studysideMessage(s) on this datasource".
}
\description{
Take a sequence of vector, matrix or data-frame arguments
and combine them by column to produce a matrix.
}
\details{
A sequence of vector, matrix or data-frame arguments
is combined column by column to produce a matrix written to the
which is written to the serverside. For more details see 
the native R function {cbind}. The handling of argument <x>
is the same as for {ds.dataFrame.o}
}
\author{
Paul Burton for DataSHIELD Development Team
}
